---
title: "Who's On First"
description: "A touch-based interactive game to pick turns fairly among multiple players. Touch the screen with multiple fingers and the game automatically picks a winner after 2 seconds of inactivity."
icon: "<i class=\"fa fa-gamepad\"></i>"
date: 2025-11-10
draft: false
type: apps
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Who's On First - Touch Turn Picker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #aaa;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info" style="display:none">Touch the screen with multiple fingers to start</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.querySelector('.info');

        // Initialize Web Audio API for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Major scale intervals (semitones) starting from C: C D E F G A B C
        // Used to pitch-shift sounds based on color index
        const majorScaleIntervals = [0, 2, 4, 5, 7, 9, 11, 12]; // semitones from base

        // Convert semitones to frequency ratio
        function semitonesToRatio(semitones) {
            return Math.pow(2, semitones / 12);
        }

        // Get the pitch ratio for a given color index
        function getPitchRatio(colorIndex) {
            const scaleIndex = colorIndex % majorScaleIntervals.length;
            const octaveOffset = Math.floor(colorIndex / majorScaleIntervals.length);
            const semitones = majorScaleIntervals[scaleIndex] + (octaveOffset * 12);
            return semitonesToRatio(semitones);
        }

        // Create simple reverb using delay lines
        function createReverbNode() {
            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            const delayNode = audioContext.createDelay(0.5);
            const delayFeedback = audioContext.createGain();
            const merger = audioContext.createChannelMerger(2);

            delayNode.delayTime.value = 0.08;
            delayFeedback.gain.value = 0.3;
            wetGain.gain.value = 0.2;
            dryGain.gain.value = 0.8;

            delayNode.connect(delayFeedback);
            delayFeedback.connect(delayNode);
            delayNode.connect(wetGain);
            dryGain.connect(merger, 0, 0);
            wetGain.connect(merger, 0, 1);

            return {
                input: dryGain,
                output: merger,
                delay: delayNode,
                wet: wetGain
            };
        }

        // Play a chirp sound (touch creation) with color-specific pitch
        function playChirpSound(colorIndex) {
            try {
                const now = audioContext.currentTime;
                const duration = 0.15;
                const pitchRatio = getPitchRatio(colorIndex);
                const baseFreq = 400 * pitchRatio;
                const endFreq = 800 * pitchRatio;

                // Create reverb
                const reverb = createReverbNode();
                reverb.output.connect(audioContext.destination);

                // Fundamental frequency
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(reverb.input);

                osc.frequency.setValueAtTime(baseFreq, now);
                osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.05, now + duration);

                osc.start(now);
                osc.stop(now + duration);
            } catch (e) {
                // Audio context may not be available on all platforms
            }
        }

        // Play a down sound (touch removal) with color-specific pitch
        function playDownSound(colorIndex) {
            try {
                const now = audioContext.currentTime;
                const duration = 0.12;
                const pitchRatio = getPitchRatio(colorIndex);
                const baseFreq = 600 * pitchRatio;
                const endFreq = 300 * pitchRatio;

                // Create reverb
                const reverb = createReverbNode();
                reverb.output.connect(audioContext.destination);

                // Fundamental frequency
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(reverb.input);

                osc.frequency.setValueAtTime(baseFreq, now);
                osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.05, now + duration);

                osc.start(now);
                osc.stop(now + duration);
            } catch (e) {
                // Audio context may not be available on all platforms
            }
        }

        // Play a "ta-da" chime sound for winner announcement
        function playTadaChime() {
            try {
                const now = audioContext.currentTime;
                const baseFreq = 520; // G5 note
                const midFreq = 659;  // E5 note
                const highFreq = 784; // G5 note (higher)

                // Create reverb
                const reverb = createReverbNode();
                reverb.output.connect(audioContext.destination);

                // First note: G5 (0.15s)
                const osc1 = audioContext.createOscillator();
                const gain1 = audioContext.createGain();
                osc1.connect(gain1);
                gain1.connect(reverb.input);
                osc1.frequency.value = baseFreq;
                gain1.gain.setValueAtTime(0.5, now);
                gain1.gain.exponentialRampToValueAtTime(0.1, now + 0.15);
                osc1.start(now);
                osc1.stop(now + 0.15);

                // Second note: E5 (0.1s, starts after first)
                const osc2 = audioContext.createOscillator();
                const gain2 = audioContext.createGain();
                osc2.connect(gain2);
                gain2.connect(reverb.input);
                osc2.frequency.value = midFreq;
                gain2.gain.setValueAtTime(0.5, now + 0.15);
                gain2.gain.exponentialRampToValueAtTime(0.1, now + 0.35);
                osc2.start(now + 0.15);
                osc2.stop(now + 0.35);

                // Third note: G5 high (0.25s, starts after second)
                const osc3 = audioContext.createOscillator();
                const gain3 = audioContext.createGain();
                osc3.connect(gain3);
                gain3.connect(reverb.input);
                osc3.frequency.value = highFreq;
                gain3.gain.setValueAtTime(0.5, now + 0.35);
                gain3.gain.exponentialRampToValueAtTime(0.05, now + 0.6);
                osc3.start(now + 0.35);
                osc3.stop(now + 0.6);
            } catch (e) {
                // Audio context may not be available on all platforms
            }
        }

        // Set canvas size with correct aspect ratio
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Debug output helper
        function updateDebugInfo(message) {
            infoDiv.textContent = message;
        }

        // Colors for touch targets - vibrant and highly differentiated palette
        const colors = [
            '#FF0080', // Hot Pink
            '#00D9FF', // Cyan
            '#00FF41', // Neon Green
            '#FFD300', // Bright Yellow
            '#FF6600', // Bright Orange
            '#9D00FF', // Bright Purple
            '#FF0040', // Red
            '#00FFAA', // Turquoise
            '#FF3366', // Deep Pink
            '#FF00FF'  // Magenta
        ];

        // Track allocated colors to ensure each touch gets a unique color
        let allocatedColorIndices = [];

        // Touch target object
        class TouchTarget {
            constructor(id, x, y, colorIndex) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.colorIndex = colorIndex;
                this.color = colors[colorIndex % colors.length];
                this.baseRadius = 65; // Increased from 40
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.spinnerRotation = 0;
                this.createdAt = Date.now();
                this.shrinkProgress = 0; // For shrinking animation
                this.shrinking = false;
            }

            update() {
                this.pulsePhase += 0.04;
                this.spinnerRotation += 0.04; // Slowed down by 50%

                if (this.shrinking) {
                    this.shrinkProgress += 0.02; // ~500ms for full shrink (0.02 * 25 frames at 50fps)
                    if (this.shrinkProgress > 1) {
                        this.shrinkProgress = 1;
                    }
                }
            }

            draw(ctx, showSpinner = true) {
                // Pulsing circle
                const pulseFactor = 0.85 + 0.15 * Math.sin(this.pulsePhase);
                let radius = this.baseRadius * pulseFactor;

                // Apply shrink animation (linear)
                if (this.shrinking) {
                    const shrinkFactor = 1 - this.shrinkProgress;
                    radius *= shrinkFactor;
                }

                // Draw pulsing circle fill
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw pulsing circle outline
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw spinner only if requested
                if (showSpinner && !this.shrinking) {
                    ctx.globalAlpha = 1;
                    drawSpinner(ctx, this.x, this.y, this.baseRadius + 15, this.color, this.spinnerRotation);
                }
            }
        }

        // Draw comet spinners around touch target
        function drawSpinner(ctx, x, y, radius, color, rotation) {
            ctx.save();
            ctx.translate(x, y);

            // Draw 3 comet-style spinners around the circle
            for (let i = 0; i < 3; i++) {
                const angle = rotation + (i * Math.PI * 2) / 3;
                const cometX = Math.cos(angle) * radius;
                const cometY = Math.sin(angle) * radius;

                // Draw curved comet tail along the circle arc
                const tailLength = 120;
                const tailRadians = tailLength / radius; // Convert tail length to angle in radians

                ctx.lineWidth = 14;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Create gradient for the tail (fading from color to transparent)
                const tailGradient = ctx.createLinearGradient(
                    Math.cos(angle) * radius, Math.sin(angle) * radius,
                    Math.cos(angle - tailRadians) * radius, Math.sin(angle - tailRadians) * radius
                );
                tailGradient.addColorStop(0, color);
                tailGradient.addColorStop(1, 'rgba(' + parseInt(color.slice(1,3),16) + ',' + parseInt(color.slice(3,5),16) + ',' + parseInt(color.slice(5,7),16) + ',0)');
                ctx.strokeStyle = tailGradient;

                // Draw curved tail along the circle arc (trailing backwards)
                ctx.beginPath();
                ctx.arc(0, 0, radius, angle, angle - tailRadians, true); // Draw arc backwards
                ctx.stroke();

                // Draw comet head (large circle)
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.95;
                ctx.beginPath();
                ctx.arc(cometX, cometY, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }

        // Winning animation - color fills from edges and zooms on winner
        class WinnerAnimation {
            constructor(winnerTarget) {
                this.winnerTarget = winnerTarget;
                this.progress = 0;
                this.duration = 1.2;
            }

            update() {
                this.progress += 0.012; // 50fps target
                return this.progress < this.duration;
            }

            draw(ctx) {
                const t = Math.min(this.progress / this.duration, 1);

                // Fill background with winning color
                ctx.fillStyle = this.winnerTarget.color;
                ctx.globalAlpha = 1;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculate shrinking black circle that starts large and shrinks to moat size
                const moatRadius = this.winnerTarget.baseRadius + 20;
                const diagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
                const maxBlackRadius = diagonal; // Start with a radius larger than the screen diagonal
                const shrinkingRadius = maxBlackRadius * (1 - t) + moatRadius * t; // Interpolate from max to moat size

                // Draw large black circle that shrinks down to reveal winning color
                ctx.fillStyle = '#000000';
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(this.winnerTarget.x, this.winnerTarget.y, shrinkingRadius, 0, Math.PI * 2);
                ctx.fill();

                // Draw the winning touch target
                ctx.globalAlpha = 1;
                this.winnerTarget.draw(ctx, false); // Don't show spinner

                ctx.globalAlpha = 1;
            }
        }

        let touchTargets = new Map();
        let lastTouchChange = 0;
        let inactivityTimer = null;
        let selectedWinner = null;
        let winnerAnimation = null;
        let gameOver = false;
        let losingTargets = []; // Store losing targets for shrink animation
        let winnerAnimationCompleteTime = null; // Track when winner animation completes
        const POST_ANIMATION_DELAY = 5000; // 5 seconds after animation ends

        function allocateColor() {
            // Find the first unallocated color
            for (let i = 0; i < colors.length; i++) {
                if (!allocatedColorIndices.includes(i)) {
                    allocatedColorIndices.push(i);
                    return i;
                }
            }
            // If all colors are allocated, cycle through them fairly
            // Use the number of touches to determine which color to reuse
            const touchCount = touchTargets.size;
            const colorIndex = (touchCount - 1) % colors.length;
            allocatedColorIndices.push(colorIndex);
            return colorIndex;
        }

        function deallocateColor(colorIndex) {
            // Remove color from allocated list when touch ends
            const index = allocatedColorIndices.indexOf(colorIndex);
            if (index > -1) {
                allocatedColorIndices.splice(index, 1);
            }
        }

        function resetInactivityTimer() {
            lastTouchChange = Date.now();
            clearTimeout(inactivityTimer);

            if (touchTargets.size > 0 && !gameOver) {
                updateDebugInfo(`${touchTargets.size} touch${touchTargets.size !== 1 ? 'es' : ''} - waiting 2s for winner...`);
                inactivityTimer = setTimeout(() => {
                    if (Date.now() - lastTouchChange >= 2000) {
                        selectWinner();
                    }
                }, 2000);
            }
        }

        function selectWinner() {
            if (touchTargets.size === 0 || winnerAnimation) return;

            const targetsArray = Array.from(touchTargets.values());
            const randomIndex = Math.floor(Math.random() * targetsArray.length);
            selectedWinner = targetsArray[randomIndex];

            updateDebugInfo(`ðŸŽ‰ Winner selected! (color index: ${selectedWinner.colorIndex})`);

            // Play ta-da chime
            playTadaChime();

            // Mark losing targets for shrinking animation
            losingTargets = targetsArray.filter(t => t.id !== selectedWinner.id);
            losingTargets.forEach(t => t.shrinking = true);

            // Start winner animation
            winnerAnimation = new WinnerAnimation(selectedWinner);
            gameOver = true;

            // Clear all touch targets
            touchTargets.clear();
        }

        function resetGame() {
            touchTargets.clear();
            selectedWinner = null;
            winnerAnimation = null;
            losingTargets = [];
            allocatedColorIndices = []; // Clear color allocations
            gameOver = false;
            clearTimeout(inactivityTimer);
            lastTouchChange = 0;
            winnerAnimationCompleteTime = null;
            updateDebugInfo('Touch the screen with multiple fingers to start');
        }

        // Trigger haptic feedback and sound for touch creation
        function playTouchCreationFeedback(colorIndex) {
            if (navigator.vibrate) {
                navigator.vibrate(20); // 20ms vibration
            }
            playChirpSound(colorIndex);
        }

        // Trigger haptic feedback and sound for touch removal
        function playTouchRemovalFeedback(colorIndex) {
            if (navigator.vibrate) {
                navigator.vibrate(15); // 15ms vibration
            }
            playDownSound(colorIndex);
        }

        // Touch event handlers
        document.addEventListener('touchstart', (e) => {
            if (gameOver) return;

            for (let touch of e.touches) {
                if (!touchTargets.has(touch.identifier)) {
                    const colorIndex = allocateColor();
                    touchTargets.set(touch.identifier, new TouchTarget(
                        touch.identifier,
                        touch.clientX,
                        touch.clientY,
                        colorIndex
                    ));
                    playTouchCreationFeedback(colorIndex);
                }
            }
            updateDebugInfo(`Touchstart: ${e.touches.length} active touch${e.touches.length !== 1 ? 'es' : ''}`);
            resetInactivityTimer();
        }, false);

        document.addEventListener('touchmove', (e) => {
            if (gameOver) return;

            for (let touch of e.touches) {
                if (touchTargets.has(touch.identifier)) {
                    const target = touchTargets.get(touch.identifier);
                    target.x = touch.clientX;
                    target.y = touch.clientY;
                }
            }
        }, false);

        document.addEventListener('touchend', (e) => {
            if (gameOver) return;

            for (let touch of e.changedTouches) {
                const target = touchTargets.get(touch.identifier);
                if (target) {
                    deallocateColor(target.colorIndex);
                    playTouchRemovalFeedback(target.colorIndex);
                }
                touchTargets.delete(touch.identifier);
            }

            if (touchTargets.size === 0) {
                clearTimeout(inactivityTimer);
                resetGame();
            } else {
                updateDebugInfo(`Touchend: ${touchTargets.size} active touch${touchTargets.size !== 1 ? 'es' : ''}`);
                resetInactivityTimer();
            }
        }, false);

        document.addEventListener('touchcancel', (e) => {
            if (gameOver) return;

            for (let touch of e.changedTouches) {
                const target = touchTargets.get(touch.identifier);
                if (target) {
                    deallocateColor(target.colorIndex);
                    playTouchRemovalFeedback(target.colorIndex);
                }
                touchTargets.delete(touch.identifier);
            }

            if (touchTargets.size === 0) {
                clearTimeout(inactivityTimer);
                resetGame();
            } else {
                updateDebugInfo(`Touchcancel: ${touchTargets.size} active touch${touchTargets.size !== 1 ? 'es' : ''}`);
                resetInactivityTimer();
            }
        }, false);

        // Mouse fallback for desktop testing
        let isMouseDown = false;
        let mouseColorIndex = 0;
        document.addEventListener('mousedown', (e) => {
            if (gameOver) return;
            isMouseDown = true;
            if (!touchTargets.has('mouse')) {
                mouseColorIndex = allocateColor();
                touchTargets.set('mouse', new TouchTarget(
                    'mouse',
                    e.clientX,
                    e.clientY,
                    mouseColorIndex
                ));
                playTouchCreationFeedback(mouseColorIndex);
            }
            updateDebugInfo('Mousedown: 1 active touch (desktop mode)');
            resetInactivityTimer();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isMouseDown || gameOver) return;
            if (touchTargets.has('mouse')) {
                const target = touchTargets.get('mouse');
                target.x = e.clientX;
                target.y = e.clientY;
            }
        });

        document.addEventListener('mouseup', (e) => {
            isMouseDown = false;
            if (gameOver) return;
            const target = touchTargets.get('mouse');
            if (target) {
                deallocateColor(target.colorIndex);
                playTouchRemovalFeedback(target.colorIndex);
            }
            touchTargets.delete('mouse');

            if (touchTargets.size === 0) {
                clearTimeout(inactivityTimer);
                resetGame();
            } else {
                updateDebugInfo(`Mouseup: ${touchTargets.size} active touch${touchTargets.size !== 1 ? 'es' : ''}`);
                resetInactivityTimer();
            }
        });

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw touch targets (only shown before game over)
            if (!gameOver) {
                touchTargets.forEach(target => {
                    target.update();
                    target.draw(ctx, true);
                });
            }

            // Update losing targets (but don't draw yet - we'll draw after winner animation)
            losingTargets.forEach(target => {
                target.update();
            });

            // Update and draw winner animation
            if (winnerAnimation) {
                const isActive = winnerAnimation.update();
                winnerAnimation.draw(ctx);

                // Also update and draw the winner during animation
                if (selectedWinner) {
                    selectedWinner.update();
                    selectedWinner.draw(ctx, false); // Don't show spinner
                }

                if (!isActive && !winnerAnimationCompleteTime) {
                    // Animation just finished, record the time
                    winnerAnimationCompleteTime = Date.now();
                }
            }

            // Draw losing targets on top of winner animation
            losingTargets.forEach(target => {
                target.draw(ctx, false); // Don't show spinner for losers
            });

            // Check if we should reset after post-animation delay
            if (winnerAnimationCompleteTime && Date.now() - winnerAnimationCompleteTime >= POST_ANIMATION_DELAY) {
                // Draw the final winner display for the remaining delay time
                if (winnerAnimation) {
                    winnerAnimation.progress = winnerAnimation.duration; // Keep animation at end state
                    winnerAnimation.draw(ctx);
                    if (selectedWinner) {
                        selectedWinner.update();
                        selectedWinner.draw(ctx, false);
                    }
                }
            } else if (winnerAnimationCompleteTime) {
                // During the delay, continue drawing the final animation state
                if (winnerAnimation) {
                    winnerAnimation.progress = winnerAnimation.duration;
                    winnerAnimation.draw(ctx);
                    if (selectedWinner) {
                        selectedWinner.update();
                        selectedWinner.draw(ctx, false);
                    }
                }
            }

            // Final reset after delay
            if (winnerAnimationCompleteTime && Date.now() - winnerAnimationCompleteTime >= POST_ANIMATION_DELAY) {
                winnerAnimation = null;
                resetGame();
            }

            ctx.globalAlpha = 1;
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
