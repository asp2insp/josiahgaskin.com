---
title: "Who's On First"
description: "A touch-based interactive game to pick turns fairly among multiple players. Touch the screen with multiple fingers and the game automatically picks a winner after 2 seconds of inactivity."
icon: "<i class=\"fa fa-gamepad\"></i>"
date: 2025-11-10
draft: false
type: apps
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Who's On First - Touch Turn Picker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #aaa;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }

        .tap-to-start {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 36px;
            font-weight: 300;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            animation: fadeIn 1.5s ease-in-out forwards;
            letter-spacing: 2px;
            transition: opacity 0.5s ease-out;
        }

        .tap-to-start.hidden {
            opacity: 0 !important;
            animation: none;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 0.6;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="tap-to-start">tap to start</div>
    <div class="info" style="display:none">Touch the screen with multiple fingers to start</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.querySelector('.info');
        const tapToStartDiv = document.querySelector('.tap-to-start');

        // Initialize Tone.js for all sounds
        // Create a reverb effect
        const reverb = new Tone.Reverb({
            decay: 2.5,
            wet: 0.3
        }).toDestination();


        // Create a membrane synth for the ta-da chime (bell-like)
        const bellSynth = new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 6,
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 0.001,
                decay: 0.4,
                sustain: 0.01,
                release: 1.0,
                attackCurve: "exponential"
            }
        }).connect(reverb);

        // Major scale notes for color-based pitch
        const majorScale = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];

        // Get note from color index
        function getNoteFromColorIndex(colorIndex) {
            return majorScale[colorIndex % majorScale.length];
        }

        // Play a chirp sound (touch creation) with color-specific pitch using Tone.js
        async function playChirpSound(colorIndex) {
            try {
                await Tone.start();
                const note = getNoteFromColorIndex(colorIndex);
                const now = Tone.now();

                // Use bellSynth for a chime-like sound
                bellSynth.triggerAttackRelease(note, "32n", now);
            } catch (e) {
                // Audio may not be available on all platforms
            }
        }

        // Play a down sound (touch removal) with color-specific pitch using Tone.js
        async function playDownSound(colorIndex) {
            try {
                await Tone.start();
                const note = getNoteFromColorIndex(colorIndex);
                const now = Tone.now();

                // Use bellSynth with lower octave for down sound
                const lowerNote = Tone.Frequency(note).transpose(-12).toNote(); // One octave down
                bellSynth.triggerAttackRelease(lowerNote, "32n", now);
            } catch (e) {
                // Audio may not be available on all platforms
            }
        }

        // Play a "ta-da" chime sound for winner announcement - New bell-like tone
        async function playTadaChime() {
            try {
                await Tone.start();
                const now = Tone.now();

                // Play an ascending arpeggio: C5 -> E5 -> G5
                bellSynth.triggerAttackRelease("C5", "8n", now);
                bellSynth.triggerAttackRelease("E5", "8n", now + 0.15);
                bellSynth.triggerAttackRelease("G5", "4n", now + 0.3);
            } catch (e) {
                // Audio may not be available on all platforms
            }
        }

        // Set canvas size with correct aspect ratio
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Debug output helper
        function updateDebugInfo(message) {
            infoDiv.textContent = message;
        }

        // Colors for touch targets - vibrant and highly differentiated palette
        const colors = [
            '#FF0080', // Hot Pink
            '#00D9FF', // Cyan
            '#00FF41', // Neon Green
            '#FFD300', // Bright Yellow
            '#FF6600', // Bright Orange
            '#9D00FF', // Bright Purple
            '#FF0040', // Red
            '#00FFAA', // Turquoise
            '#FF3366', // Deep Pink
            '#FF00FF'  // Magenta
        ];

        // Track allocated colors to ensure each touch gets a unique color
        let allocatedColorIndices = [];

        // Touch target object
        class TouchTarget {
            constructor(id, x, y, colorIndex) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.colorIndex = colorIndex;
                this.color = colors[colorIndex % colors.length];
                this.baseRadius = 65; // Increased from 40
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.spinnerRotation = 0;
                this.createdAt = Date.now();
                this.shrinkProgress = 0; // For shrinking animation
                this.shrinking = false;
            }

            update() {
                this.pulsePhase += 0.04;
                this.spinnerRotation += 0.04; // Slowed down by 50%

                if (this.shrinking) {
                    this.shrinkProgress += 0.02; // ~500ms for full shrink (0.02 * 25 frames at 50fps)
                    if (this.shrinkProgress > 1) {
                        this.shrinkProgress = 1;
                    }
                }
            }

            draw(ctx, showSpinner = true) {
                // Pulsing circle
                const pulseFactor = 0.85 + 0.15 * Math.sin(this.pulsePhase);
                let radius = this.baseRadius * pulseFactor;

                // Apply shrink animation (linear)
                if (this.shrinking) {
                    const shrinkFactor = 1 - this.shrinkProgress;
                    radius *= shrinkFactor;
                }

                // Draw pulsing circle fill
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw pulsing circle outline
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw spinner only if requested
                if (showSpinner && !this.shrinking) {
                    ctx.globalAlpha = 1;
                    drawSpinner(ctx, this.x, this.y, this.baseRadius + 15, this.color, this.spinnerRotation);
                }
            }
        }

        // Draw comet spinners around touch target
        function drawSpinner(ctx, x, y, radius, color, rotation) {
            ctx.save();
            ctx.translate(x, y);

            // Draw 3 comet-style spinners around the circle
            for (let i = 0; i < 3; i++) {
                const angle = rotation + (i * Math.PI * 2) / 3;
                const cometX = Math.cos(angle) * radius;
                const cometY = Math.sin(angle) * radius;

                // Draw curved comet tail along the circle arc
                const tailLength = 120;
                const tailRadians = tailLength / radius; // Convert tail length to angle in radians

                ctx.lineWidth = 14;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Create gradient for the tail (fading from color to transparent)
                const tailGradient = ctx.createLinearGradient(
                    Math.cos(angle) * radius, Math.sin(angle) * radius,
                    Math.cos(angle - tailRadians) * radius, Math.sin(angle - tailRadians) * radius
                );
                tailGradient.addColorStop(0, color);
                tailGradient.addColorStop(1, 'rgba(' + parseInt(color.slice(1,3),16) + ',' + parseInt(color.slice(3,5),16) + ',' + parseInt(color.slice(5,7),16) + ',0)');
                ctx.strokeStyle = tailGradient;

                // Draw curved tail along the circle arc (trailing backwards)
                ctx.beginPath();
                ctx.arc(0, 0, radius, angle, angle - tailRadians, true); // Draw arc backwards
                ctx.stroke();

                // Draw comet head (large circle)
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.95;
                ctx.beginPath();
                ctx.arc(cometX, cometY, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }

        // Winning animation - color fills from edges and zooms on winner
        class WinnerAnimation {
            constructor(winnerTarget) {
                this.winnerTarget = winnerTarget;
                this.progress = 0;
                this.duration = 1.2;
            }

            update() {
                this.progress += 0.012; // 50fps target
                return this.progress < this.duration;
            }

            draw(ctx) {
                const t = Math.min(this.progress / this.duration, 1);

                // Fill background with winning color
                ctx.fillStyle = this.winnerTarget.color;
                ctx.globalAlpha = 1;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculate shrinking black circle that starts large and shrinks to moat size
                const moatRadius = this.winnerTarget.baseRadius + 20;
                const diagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
                const maxBlackRadius = diagonal; // Start with a radius larger than the screen diagonal
                const shrinkingRadius = maxBlackRadius * (1 - t) + moatRadius * t; // Interpolate from max to moat size

                // Draw large black circle that shrinks down to reveal winning color
                ctx.fillStyle = '#000000';
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(this.winnerTarget.x, this.winnerTarget.y, shrinkingRadius, 0, Math.PI * 2);
                ctx.fill();

                // Draw the winning touch target
                ctx.globalAlpha = 1;
                this.winnerTarget.draw(ctx, false); // Don't show spinner

                ctx.globalAlpha = 1;
            }
        }

        // Score tracker for each player
        class ScoreCircle {
            constructor(id, x, y, color, colorIndex, playerNumber = 1) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.color = color;
                this.colorIndex = colorIndex;
                this.score = 0;
                this.radius = 60;
                this.buttonDistance = 80; // Distance from center to button arc
                this.buttonArcLength = 0.6; // Angular width of each button (radians) - increased from 0.45
                this.buttonThickness = 22; // Radial thickness of button
                this.isDragging = false;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
                this.lastButtonPressTime = 0; // For debouncing
                this.buttonDebounceDelay = 150; // 150ms debounce
                this.playerNumber = playerNumber;
                this.playerName = `Player ${playerNumber}`;
                this.isEditingName = false;
                this.nameInputValue = this.playerName;
                this.lastNameEditTime = 0; // For debouncing name edits
                this.nameEditDebounceDelay = 300; // 300ms debounce for name edits
            }

            // Check if point is inside the main circle
            containsPoint(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.radius;
            }

            // Check if point is on the name field (below the circle)
            isNameFieldAt(x, y) {
                const nameY = this.y + this.radius + 60; // Moved down to avoid button collision
                const nameHeight = 20;
                const nameWidth = 120;
                const nameX = this.x - nameWidth / 2;

                return x >= nameX && x <= nameX + nameWidth &&
                       y >= nameY - nameHeight / 2 && y <= nameY + nameHeight / 2;
            }

            // Check if point is on an arc button and return the button value
            getButtonAt(x, y) {
                const buttons = [
                    { value: 1, angle: -Math.PI / 2 - 0.75 },     // Top left: +1
                    { value: 5, angle: -Math.PI / 2 },            // Top center: +5
                    { value: 10, angle: -Math.PI / 2 + 0.75 },    // Top right: +10
                    { value: -1, angle: Math.PI / 2 - 0.75 },     // Bottom left: -1
                    { value: -5, angle: Math.PI / 2 },            // Bottom center: -5
                    { value: -10, angle: Math.PI / 2 + 0.75 }     // Bottom right: -10
                ];

                const dx = x - this.x;
                const dy = y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                for (let button of buttons) {
                    // Check if point is within the radial range of the button
                    const innerRadius = this.buttonDistance - this.buttonThickness / 2;
                    const outerRadius = this.buttonDistance + this.buttonThickness / 2;

                    if (distance >= innerRadius && distance <= outerRadius) {
                        // Check if point is within the angular range of the button
                        let angleDiff = angle - button.angle;
                        // Normalize angle difference to [-PI, PI]
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                        if (Math.abs(angleDiff) <= this.buttonArcLength / 2) {
                            return button.value;
                        }
                    }
                }
                return null;
            }

            adjustScore(delta) {
                // Debounce: check if enough time has passed since last button press
                const now = Date.now();
                if (now - this.lastButtonPressTime < this.buttonDebounceDelay) {
                    return; // Ignore this press, too soon after last one
                }
                this.lastButtonPressTime = now;

                this.score += delta;
                // Play different sounds for increment vs decrement
                if (delta > 0) {
                    playChirpSound(this.colorIndex);
                } else {
                    playDownSound(this.colorIndex);
                }
            }

            draw(ctx) {
                // Draw main circle
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw score text (use monospace for consistent centering)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 32px "SF Mono", "Monaco", "Menlo", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // For negative numbers, manually offset to keep visual center
                const scoreText = this.score.toString();
                const isNegative = this.score < 0;
                const offsetX = isNegative ? -4 : 0; // Slight left offset for negative numbers
                ctx.fillText(scoreText, this.x + offsetX, this.y);

                // Draw player name field below circle
                const nameY = this.y + this.radius + 60; // Moved down to avoid button collision
                const nameWidth = 120;
                const nameHeight = 20;
                const nameX = this.x - nameWidth / 2;

                // Draw name background box
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.roundRect(nameX, nameY - nameHeight / 2, nameWidth, nameHeight, 4);
                ctx.fill();

                // Draw name border
                ctx.globalAlpha = 1;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(nameX, nameY - nameHeight / 2, nameWidth, nameHeight, 4);
                ctx.stroke();

                // Draw name text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 0.9;
                ctx.fillText(this.playerName, this.x, nameY);

                // Draw buttons as arc segments
                this.drawButtons(ctx);
            }

            drawButtons(ctx) {
                const buttons = [
                    { label: '+1', value: 1, angle: -Math.PI / 2 - 0.75 },
                    { label: '+5', value: 5, angle: -Math.PI / 2 },
                    { label: '+10', value: 10, angle: -Math.PI / 2 + 0.75 },
                    { label: '', value: 0, angle: -Math.PI / 2 + 1.5 }, // Spacer
                    { label: '-1', value: -1, angle: Math.PI / 2 - 0.75 },
                    { label: '-5', value: -5, angle: Math.PI / 2 },
                    { label: '-10', value: -10, angle: Math.PI / 2 + 0.75 },
                    { label: '', value: 0, angle: Math.PI / 2 + 1.5 }  // Spacer
                ];

                const innerRadius = this.buttonDistance - this.buttonThickness / 2;
                const outerRadius = this.buttonDistance + this.buttonThickness / 2;

                // Calculate gutter size between buttons
                const buttonSpacing = 0.75; // Angular spacing between button centers
                const gutterSize = buttonSpacing - this.buttonArcLength;

                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.globalAlpha = 1;

                // Draw interactive buttons and spacers
                buttons.forEach(button => {
                    // Check if this is a spacer (empty label and value 0)
                    const isSpacer = button.label === '' && button.value === 0;

                    let startAngle, endAngle;

                    if (isSpacer) {
                        // Calculate spacer arc length to fill remaining space on the side
                        // Right side spacer (angle 1.5 from top, approximately 0 radians or right side)
                        if (Math.abs(button.angle - (-Math.PI / 2 + 1.5)) < 0.1) {
                            // Right side: from end of +10 button to start of -1 button
                            startAngle = -Math.PI / 2 + 0.75 + this.buttonArcLength / 2 + gutterSize;
                            endAngle = Math.PI / 2 - 0.75 - this.buttonArcLength / 2 - gutterSize;
                        } else {
                            // Left side: from end of -10 button to start of +1 button
                            startAngle = Math.PI / 2 + 0.75 + this.buttonArcLength / 2 + gutterSize;
                            endAngle = -Math.PI / 2 - 0.75 - this.buttonArcLength / 2 - gutterSize + 2 * Math.PI;
                        }
                    } else {
                        // Regular button uses standard arc length
                        startAngle = button.angle - this.buttonArcLength / 2;
                        endAngle = button.angle + this.buttonArcLength / 2;
                    }

                    // Create arc path
                    ctx.beginPath();
                    ctx.arc(0, 0, outerRadius, startAngle, endAngle);
                    ctx.arc(0, 0, innerRadius, endAngle, startAngle, true);
                    ctx.closePath();

                    // Fill button/spacer
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = isSpacer ? 0.3 : 0.7; // Spacers are more transparent
                    ctx.fill();

                    // Stroke button/spacer
                    ctx.globalAlpha = isSpacer ? 0.5 : 1; // Spacers have semi-transparent outline
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw button label (only for non-spacers)
                    if (!isSpacer) {
                        const labelAngle = button.angle;
                        const labelX = Math.cos(labelAngle) * this.buttonDistance;
                        const labelY = Math.sin(labelAngle) * this.buttonDistance;

                        ctx.globalAlpha = 1;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(button.label, labelX, labelY);
                    }
                });

                ctx.restore();
            }
        }

        // Reset button at bottom of screen
        class ResetButton {
            constructor() {
                this.width = 120;
                this.height = 50;
                this.x = 0; // Will be centered
                this.y = 0; // Will be positioned at bottom
            }

            updatePosition(canvasWidth, canvasHeight) {
                this.x = canvasWidth / 2 - this.width / 2;
                // Use larger bottom offset for mobile to account for browser chrome
                const bottomOffset = 80;
                this.y = canvasHeight - this.height - bottomOffset;
            }

            containsPoint(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }

            draw(ctx, canvasWidth, canvasHeight) {
                this.updatePosition(canvasWidth, canvasHeight);

                // Draw button background (transparent)
                ctx.globalAlpha = 1;

                // Draw button outline (dark grey)
                ctx.strokeStyle = '#444444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 10);
                ctx.stroke();

                // Draw button text (lighter grey)
                ctx.fillStyle = '#888888';
                ctx.font = 'bold 16px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('RESET', this.x + this.width / 2, this.y + this.height / 2);

                ctx.globalAlpha = 1;
            }
        }

        let touchTargets = new Map();
        let lastTouchChange = 0;
        let inactivityTimer = null;
        let selectedWinner = null;
        let winnerAnimation = null;
        let gameOver = false;
        let losingTargets = []; // Store losing targets for shrink animation
        let winnerAnimationCompleteTime = null; // Track when winner animation completes
        const POST_ANIMATION_DELAY = 2000; // 2 seconds after animation ends before transitioning to score mode

        // Score tracking mode
        let scoreTrackingMode = false;
        let scoreCircles = [];
        let resetButton = new ResetButton();
        let draggedCircle = null;
        let isNamePromptOpen = false; // Flag to prevent duplicate name prompts

        function allocateColor() {
            // Find the first unallocated color
            for (let i = 0; i < colors.length; i++) {
                if (!allocatedColorIndices.includes(i)) {
                    allocatedColorIndices.push(i);
                    return i;
                }
            }
            // If all colors are allocated, cycle through them fairly
            // Use the number of touches to determine which color to reuse
            const touchCount = touchTargets.size;
            const colorIndex = (touchCount - 1) % colors.length;
            allocatedColorIndices.push(colorIndex);
            return colorIndex;
        }

        function deallocateColor(colorIndex) {
            // Remove color from allocated list when touch ends
            const index = allocatedColorIndices.indexOf(colorIndex);
            if (index > -1) {
                allocatedColorIndices.splice(index, 1);
            }
        }

        function resetInactivityTimer() {
            lastTouchChange = Date.now();
            clearTimeout(inactivityTimer);

            if (touchTargets.size > 0 && !gameOver) {
                updateDebugInfo(`${touchTargets.size} touch${touchTargets.size !== 1 ? 'es' : ''} - waiting 2s for winner...`);
                inactivityTimer = setTimeout(() => {
                    if (Date.now() - lastTouchChange >= 2000) {
                        selectWinner();
                    }
                }, 2000);
            }
        }

        function selectWinner() {
            if (touchTargets.size === 0 || winnerAnimation) return;

            const targetsArray = Array.from(touchTargets.values());
            const randomIndex = Math.floor(Math.random() * targetsArray.length);
            selectedWinner = targetsArray[randomIndex];

            updateDebugInfo(`ðŸŽ‰ Winner selected! (color index: ${selectedWinner.colorIndex})`);

            // Play ta-da chime
            playTadaChime();

            // Create randomized player order for turn order display
            const playerNumbers = Array.from({length: targetsArray.length}, (_, i) => i + 1);
            // Shuffle player numbers
            for (let i = playerNumbers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [playerNumbers[i], playerNumbers[j]] = [playerNumbers[j], playerNumbers[i]];
            }

            // Save all touch targets as score circles for later with randomized player numbers
            scoreCircles = targetsArray.map((target, index) =>
                new ScoreCircle(target.id, target.x, target.y, target.color, target.colorIndex, playerNumbers[index])
            );

            // Mark losing targets for shrinking animation
            losingTargets = targetsArray.filter(t => t.id !== selectedWinner.id);
            losingTargets.forEach(t => t.shrinking = true);

            // Start winner animation
            winnerAnimation = new WinnerAnimation(selectedWinner);
            gameOver = true;

            // Clear all touch targets
            touchTargets.clear();
        }

        function resetGame() {
            touchTargets.clear();
            selectedWinner = null;
            winnerAnimation = null;
            losingTargets = [];
            allocatedColorIndices = []; // Clear color allocations
            gameOver = false;
            scoreTrackingMode = false;
            scoreCircles = [];
            draggedCircle = null;
            isNamePromptOpen = false; // Clear prompt flag

            clearTimeout(inactivityTimer);
            lastTouchChange = 0;
            winnerAnimationCompleteTime = null;
            updateDebugInfo('Touch the screen with multiple fingers to start');

            // Show "tap to start" again
            if (tapToStartDiv) {
                tapToStartDiv.classList.remove('hidden');
            }
        }

        // Trigger haptic feedback and sound for touch creation
        function playTouchCreationFeedback(colorIndex) {
            if (navigator.vibrate) {
                navigator.vibrate(20); // 20ms vibration
            }
            playChirpSound(colorIndex);
        }

        // Trigger haptic feedback and sound for touch removal
        function playTouchRemovalFeedback(colorIndex) {
            if (navigator.vibrate) {
                navigator.vibrate(15); // 15ms vibration
            }
            playDownSound(colorIndex);
        }

        // Touch event handlers for score tracking mode
        function handleScoreModeTouch(x, y) {
            // Check if reset button was clicked
            if (resetButton.containsPoint(x, y)) {
                resetGame();
                return true;
            }

            // Check if any score circle name field was clicked
            for (let circle of scoreCircles) {
                if (circle.isNameFieldAt(x, y)) {
                    // Don't open a new prompt if one is already open
                    if (isNamePromptOpen) {
                        return true;
                    }

                    // Debounce: check if enough time has passed since last name edit
                    const now = Date.now();
                    if (now - circle.lastNameEditTime < circle.nameEditDebounceDelay) {
                        return true; // Ignore this press, too soon after last one
                    }
                    circle.lastNameEditTime = now;

                    isNamePromptOpen = true;
                    circle.isEditingName = true;
                    circle.nameInputValue = circle.playerName;
                    // Prompt for name edit
                    const newName = prompt('Enter player name:', circle.playerName);
                    if (newName !== null && newName.trim() !== '') {
                        circle.playerName = newName.trim();
                    }
                    circle.isEditingName = false;
                    isNamePromptOpen = false;
                    return true;
                }
            }

            // Check if any score circle button was clicked
            for (let circle of scoreCircles) {
                const buttonValue = circle.getButtonAt(x, y);
                if (buttonValue !== null) {
                    circle.adjustScore(buttonValue);
                    return true;
                }
            }

            // Check if dragging a score circle
            for (let circle of scoreCircles) {
                if (circle.containsPoint(x, y)) {
                    draggedCircle = circle;
                    circle.isDragging = true;
                    circle.dragOffsetX = x - circle.x;
                    circle.dragOffsetY = y - circle.y;
                    return true;
                }
            }

            return false;
        }

        function handleScoreModeDrag(x, y) {
            if (draggedCircle && draggedCircle.isDragging) {
                draggedCircle.x = x - draggedCircle.dragOffsetX;
                draggedCircle.y = y - draggedCircle.dragOffsetY;
                return true;
            }
            return false;
        }

        function handleScoreModeRelease() {
            if (draggedCircle) {
                draggedCircle.isDragging = false;
                draggedCircle = null;
                return true;
            }
            return false;
        }

        // Hide "tap to start" on first interaction
        function hideTapToStart() {
            if (tapToStartDiv && !tapToStartDiv.classList.contains('hidden')) {
                tapToStartDiv.classList.add('hidden');
            }
        }

        // Touch event handlers
        document.addEventListener('touchstart', (e) => {
            hideTapToStart();

            if (scoreTrackingMode) {
                const touch = e.touches[0];
                if (handleScoreModeTouch(touch.clientX, touch.clientY)) {
                    e.preventDefault();
                }
                return;
            }

            if (gameOver) return;

            for (let touch of e.touches) {
                if (!touchTargets.has(touch.identifier)) {
                    const colorIndex = allocateColor();
                    touchTargets.set(touch.identifier, new TouchTarget(
                        touch.identifier,
                        touch.clientX,
                        touch.clientY,
                        colorIndex
                    ));
                    playTouchCreationFeedback(colorIndex);
                }
            }
            updateDebugInfo(`Touchstart: ${e.touches.length} active touch${e.touches.length !== 1 ? 'es' : ''}`);
            resetInactivityTimer();
        }, false);

        document.addEventListener('touchmove', (e) => {
            if (scoreTrackingMode) {
                const touch = e.touches[0];
                if (handleScoreModeDrag(touch.clientX, touch.clientY)) {
                    e.preventDefault();
                }
                return;
            }

            if (gameOver) return;

            for (let touch of e.touches) {
                if (touchTargets.has(touch.identifier)) {
                    const target = touchTargets.get(touch.identifier);
                    target.x = touch.clientX;
                    target.y = touch.clientY;
                }
            }
        }, false);

        document.addEventListener('touchend', (e) => {
            if (scoreTrackingMode) {
                handleScoreModeRelease();
                return;
            }

            if (gameOver) return;

            for (let touch of e.changedTouches) {
                const target = touchTargets.get(touch.identifier);
                if (target) {
                    deallocateColor(target.colorIndex);
                    playTouchRemovalFeedback(target.colorIndex);
                }
                touchTargets.delete(touch.identifier);
            }

            if (touchTargets.size === 0) {
                clearTimeout(inactivityTimer);
                resetGame();
            } else {
                updateDebugInfo(`Touchend: ${touchTargets.size} active touch${touchTargets.size !== 1 ? 'es' : ''}`);
                resetInactivityTimer();
            }
        }, false);

        document.addEventListener('touchcancel', (e) => {
            if (scoreTrackingMode) {
                handleScoreModeRelease();
                return;
            }

            if (gameOver) return;

            for (let touch of e.changedTouches) {
                const target = touchTargets.get(touch.identifier);
                if (target) {
                    deallocateColor(target.colorIndex);
                    playTouchRemovalFeedback(target.colorIndex);
                }
                touchTargets.delete(touch.identifier);
            }

            if (touchTargets.size === 0) {
                clearTimeout(inactivityTimer);
                resetGame();
            } else {
                updateDebugInfo(`Touchcancel: ${touchTargets.size} active touch${touchTargets.size !== 1 ? 'es' : ''}`);
                resetInactivityTimer();
            }
        }, false);

        // Mouse fallback for desktop testing
        let isMouseDown = false;
        let mouseColorIndex = 0;
        document.addEventListener('mousedown', (e) => {
            hideTapToStart();

            if (scoreTrackingMode) {
                handleScoreModeTouch(e.clientX, e.clientY);
                isMouseDown = true;
                return;
            }

            if (gameOver) return;
            isMouseDown = true;
            if (!touchTargets.has('mouse')) {
                mouseColorIndex = allocateColor();
                touchTargets.set('mouse', new TouchTarget(
                    'mouse',
                    e.clientX,
                    e.clientY,
                    mouseColorIndex
                ));
                playTouchCreationFeedback(mouseColorIndex);
            }
            updateDebugInfo('Mousedown: 1 active touch (desktop mode)');
            resetInactivityTimer();
        });

        document.addEventListener('mousemove', (e) => {
            if (scoreTrackingMode) {
                if (isMouseDown) {
                    handleScoreModeDrag(e.clientX, e.clientY);
                }
                return;
            }

            if (!isMouseDown || gameOver) return;
            if (touchTargets.has('mouse')) {
                const target = touchTargets.get('mouse');
                target.x = e.clientX;
                target.y = e.clientY;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (scoreTrackingMode) {
                handleScoreModeRelease();
                isMouseDown = false;
                return;
            }

            isMouseDown = false;
            if (gameOver) return;
            const target = touchTargets.get('mouse');
            if (target) {
                deallocateColor(target.colorIndex);
                playTouchRemovalFeedback(target.colorIndex);
            }
            touchTargets.delete('mouse');

            if (touchTargets.size === 0) {
                clearTimeout(inactivityTimer);
                resetGame();
            } else {
                updateDebugInfo(`Mouseup: ${touchTargets.size} active touch${touchTargets.size !== 1 ? 'es' : ''}`);
                resetInactivityTimer();
            }
        });

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Score tracking mode
            if (scoreTrackingMode) {
                // Draw all score circles
                scoreCircles.forEach(circle => {
                    circle.draw(ctx);
                });

                // Draw reset button (use getBoundingClientRect for actual viewport dimensions)
                const rect = canvas.getBoundingClientRect();
                resetButton.draw(ctx, rect.width, rect.height);

                ctx.globalAlpha = 1;
                requestAnimationFrame(animate);
                return;
            }

            // Update and draw touch targets (only shown before game over)
            if (!gameOver) {
                touchTargets.forEach(target => {
                    target.update();
                    target.draw(ctx, true);
                });
            }

            // Update losing targets (but don't draw yet - we'll draw after winner animation)
            losingTargets.forEach(target => {
                target.update();
            });

            // Update and draw winner animation
            if (winnerAnimation) {
                const isActive = winnerAnimation.update();
                winnerAnimation.draw(ctx);

                // Also update and draw the winner during animation
                if (selectedWinner) {
                    selectedWinner.update();
                    selectedWinner.draw(ctx, false); // Don't show spinner
                }

                if (!isActive && !winnerAnimationCompleteTime) {
                    // Animation just finished, record the time
                    winnerAnimationCompleteTime = Date.now();
                }
            }

            // Draw losing targets on top of winner animation
            losingTargets.forEach(target => {
                target.draw(ctx, false); // Don't show spinner for losers
            });

            // Check if we should transition to score tracking after post-animation delay
            if (winnerAnimationCompleteTime && Date.now() - winnerAnimationCompleteTime >= POST_ANIMATION_DELAY) {
                // Transition to score tracking mode
                scoreTrackingMode = true;
                winnerAnimation = null;
                losingTargets = [];
                updateDebugInfo('Score tracking mode - drag circles to reposition');
            } else if (winnerAnimationCompleteTime) {
                // During the delay, continue drawing the final animation state
                if (winnerAnimation) {
                    winnerAnimation.progress = winnerAnimation.duration;
                    winnerAnimation.draw(ctx);
                    if (selectedWinner) {
                        selectedWinner.update();
                        selectedWinner.draw(ctx, false);
                    }
                }
            }

            ctx.globalAlpha = 1;
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
